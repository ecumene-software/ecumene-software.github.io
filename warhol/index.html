<!doctype html>
<html>
	<head>
		<title>learningthree.js boiler plate for three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">


		<script src="build/three.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/loaders/OBJLoader.js"></script>
    <script src="js/loaders/MTLLoader.js"></script>
    <script src="js/controls/TrackballControls.js"></script>
	</head>
<body>
	<!-- three.js container -->
    	<div id="container"></div>
	<!-- info on screen display -->
	<div id="info">
		<div class="top">
			<a href="http://learningthreejs.com/blog/2011/12/20/boilerplate-for-three-js/" target="_blank">LearningThree.js</a>
			boiler plate for
			<a href="https://github.com/mrdoob/three.js/" target="_blank">three.js</a>
		</div>
		<div class="bottom" id="inlineDoc" >
			- <i>p</i> for screenshot
		</div>
	</div>

  <script type="x-shader/x-vertex" id="vertexShader">
    varying vec3 vWorldPosition;
    void main() {
      vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      vWorldPosition = worldPosition.xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader">
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float offset;
    uniform float exponent;
    varying vec3 vWorldPosition;
    void main() {
      float h = normalize( vWorldPosition + offset ).y;
      gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
    }
  </script>


	<script type="text/javascript">
		var stats, scene, renderer;
		var camera, cameraControl;


		if( !init() )	animate();

		// init the scene
		function init(){

			// create a scene
			scene = new THREE.Scene();

			scene.fog = new THREE.Fog( 0xffffff, 1, 5000 );
			scene.fog.color.setHSL( 0.6, 0, 1 );

			// put a camera in the scene
			camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.set(0, 0, 20);
			scene.add(camera);

      cameraControl = new THREE.TrackballControls( camera );
      cameraControl.rotateSpeed = 1.0;
      cameraControl.zoomSpeed = 1.2;
      cameraControl.panSpeed = 0.8;
      cameraControl.noZoom = false;
      cameraControl.noPan = false;
      cameraControl.staticMoving = true;
      cameraControl.dynamicDampingFactor = 0.3;
      cameraControl.keys = [ 65, 83, 68 ];
      cameraControl.addEventListener( 'change', render );


      hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
      hemiLight.color.setHSL( 0.6, 1, 0.6 );
      hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
      hemiLight.position.set( 0, 500, 0 );
      scene.add( hemiLight );


			dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );

      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      var d = 50;

      dirLight.shadow.camera.left = -d;
      dirLight.shadow.camera.right = d;
      dirLight.shadow.camera.top = d;
      dirLight.shadow.camera.bottom = -d;
      dirLight.shadow.camera.far = 3500;
      dirLight.shadow.bias = -0.0001;

      var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
      var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
      groundMat.color.setHSL( 0.095, 1, 0.75 );

      var ground = new THREE.Mesh( groundGeo, groundMat );
      ground.rotation.x = -Math.PI/2;
      ground.position.y = -33;
      scene.add( ground );

      var vertexShader = document.getElementById( 'vertexShader' ).textContent;
      var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
      var uniforms = {
        topColor:    { value: new THREE.Color( 0x0077ff ) },
        bottomColor: { value: new THREE.Color( 0xffffff ) },
        offset:      { value: 33 },
        exponent:    { value: 0.6 }
      };
      uniforms.topColor.value.copy( hemiLight.color );
      scene.fog.color.copy( uniforms.bottomColor.value );
      var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
      var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );
      var sky = new THREE.Mesh( skyGeo, skyMat );
      scene.add( sky );

      var objLoader = new THREE.OBJLoader();
      var mtlLoader = new THREE.MTLLoader();

      mtlLoader.setPath('model/');
      mtlLoader.load('soup.mtl', function(materials) {
        materials.preload();
        var objLoader = new THREE.OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath('model/');
        objLoader.load('soup.obj', function(object) {
          scene.add(object);
        });
      });

      if( Detector.webgl ){
        renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.renderReverseSided = false;
			}else{
			  	Detector.addGetWebGLMessage();
			    return true;
			}
			document.getElementById('container').appendChild(renderer.domElement);

		}

		// animation loop
		function animate() {

			// loop on request animation loop
			// - it has to be at the begining of the function
			// - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
			requestAnimationFrame( animate );
      cameraControl.update();
			// do the render
			render();

		}

		// render the scene
		function render() {
      renderer.clearColor(1, 1, 1, 1 );
      renderer.clear(render.COLOR_BUFFER_BIT);

			// actually render the scene
			renderer.render( scene, camera );
		}
	</script>
</body>
</html>
